---
title: 'Seaweeds in Two Oceans: Beta-Diversity (Appendices)'
author:
- affiliation: University of the Western Cape
  name: AJ Smit
- affiliation: University of Cape Town
  name: JJ Bolton
- affiliation: Department of Agriculture, Forestry and Fisheries and University of Cape Town
  name: RJ Anderson
date: "19 March 2017"
bibliography: ../references.bib
format:
  html:
    eval: false
---

```{r code-brewing-opts, echo=FALSE}
knitr::opts_chunk$set(
  comment = "R>", 
  warning = FALSE, 
  message = FALSE,
  fig.width = 4.5,
  fig.height = 2.625,
  out.width = "75%",
  fig.asp = NULL, # control via width/height
  dpi = 300
)

ggplot2::theme_set(
  ggplot2::theme_minimal(base_size = 8)
)
ggplot2::theme_set(
  ggplot2::theme_bw(base_size = 8)
)
```

In this document you will find examples of a fairly complicated series of constrained ordinations performed for the paper @smit2017seaweeds. The analyses are based on the distribution of seaweeds around the coast of South Africa, and the environmental variables that might explain these distributions. 

## Spatial Analysis Background and Code

This is Appendix B of the paper @smit2017seaweeds.

The intention of this section is to show the approach and **R** scripts used to pull apart the spatial scales at which seaweed assemblages are structured around the coast of South Africa. Specifically, I wish to determine if these scales match those expressed by the coastal thermal provinces and the ocean regime underpinned by the Agulhas and Benguela Currents.

## The Data

I use two data sets. The first, $Y$, comprises distribution records of 846 macroalgal species within each of 58 × 50 km-long sections (Appendix A) of the South African coast [updated from @Bolton2002]. This represents *ca*. 90% of the known seaweed flora of South Africa, but excludes some very small and/or very rare species for which data are insufficient. The data are from verifiable literature sources and John Bolton and Rob Anderson's own collections, assembled from information collected by teams of phycologists over three decades [@Bolton1986; @Stegenga1997; @Bolton2002; @DeClerck2005]. The second, $E$, is a dataset of *in situ* coastal seawater temperatures [@Smit2013] derived from daily measurements over up to 40 years.

A third data set of explanatory variables --- the spatial variables ($S$) --- is constructed as per the instructions in section *Preparation of spatial variables*, later on.

## Setting up the Analysis Environment

This is **R**, so first I need to find, install, and load various packages. Some of the packages will be available on CRAN and can be accessed and installed in the usual way, but others will have to be downloaded from [R Forge](https://r-forge.r-project.org/R/?group_id=195).

Note: R-Forge repositories can be fragile (packages can disappear, builds can fail, and HTTP repos may be blocked). If you cannot install an R-Forge package, look for a CRAN/GitHub alternative, or ask for a pre-packaged/locked environment.

```{r code-setup}
library(betapart)
library(vegan)
library(gridExtra)
library(grid)
library(gridBase)
library(ggpubr)
library(tidyr)
library(spdep) # for dnearneigh() in PCNM.R
# library(devtools)
# install.packages("packfor", repos = "http://R-Forge.R-project.org")
# library(packfor) # replaced with vegan::ordistep()
# install.packages("AEM", repos = "http://R-Forge.R-project.org")
# library(AEM) # for moran.I.multi() in PCNM.R
source(here::here("R", "pcoa_all.R"))
source(here::here("R", "PCNM.R"))
source(here::here("R", "spatial_MEM.R"))
```

Now I get to the data. The first step involves the species table ($Y$). First I compute the Sørensen dissimilarity and then I decompose the dissimilarity into the 'turnover' (β\textsubscript{sim}) and 'nestedness-resultant' (β\textsubscript{sne}) components [@Baselga2010; @Baselga2013] using the `betapart.core()` and `betapart.pair()` functions of the **betapart** package [@Baselga2013]. These are placed into the matrices $Y1$ and $Y2$. Optionally, I can apply a principal components analysis (PCA) on $Y$ to find the major patterns in the community data. In **vegan** this is done using the `rda()` function and not supplying the constraints (*i.e.*, the environment table, $E$, or the spatial table, $S$). The formal analysis will use the species data in distance-based redundancy analyses (db-RDA as per **vegan**'s `capscale()` function) by coupling them with $E$ and $S$. I provide the pre-calculated data only.

```{r code-species-data}
# Read in the species data (note: on GitHub only the distance
# matrices obtained via 'beta.part' and 'beta.pair' (below)
# will be provided -- they are read in as 'Y1.Rdata' and 'Y2.Rdata':
spp <- read.csv(here::here("data", "BCB743", "seaweed", "SeaweedSpp.csv"))
spp <- dplyr::select(spp, -1)

# Decompose total Sørensen dissimilarity into turnover and
# nestedness-resultant components:
Y.core <- betapart.core(spp)
Y.pair <- beta.pair(Y.core, index.family = "sor")

# Let Y1 be the turnover component (beta-sim):
Y1 <- as.matrix(Y.pair$beta.sim)
# save(Y1, file = "data/BCB743/Y1.Rdata")
# load("data/BCB743/Y1.Rdata")

# Let Y2 be the nestedness-resultant component (beta-sne):
Y2 <- as.matrix(Y.pair$beta.sne)
# save(Y2, file = "data/BCB743/Y2.Rdata")
# load("data/BCB743/Y2.Rdata")
```

```{r code-summary-capscale-y1}
summary(capscale(Y1 ~ 1))
```

It is now necessary to load the environmental data and some setup files that partition the 58 coastal sections (and the species and environmental data that fall within these sections) into bioregions.

The thermal (environmental) data contain various variables, but in the analysis I use only some of them. These data were obtained from many sites along the South African coast, but using interpolation (not included here) I calculated the thermal properties for each of the coastal sections for which seaweed data are available. Consequently we have a data frame with 58 rows and a column for each of the thermal metrics. Before use, I apply **vegan**'s `decostand()` function to scale the data to zero mean and unit variance.

Four bioregions are recognised for South Africa [@Bolton2004], namely the Benguela Marine Province (BMP; coastal sections **1**--**17**), the Benguela-Agulhas Transition Zone (B-ATZ; **18**--**22**), the Agulhas Marine Province (AMP; **19**--**43**/**44**), and the East Coast Transition Zone (ECTZ; **44**/**45**--**58**). My plotting functions partition the data into the bioregions and colour code the figures accordingly so I can see regional patterns in \textbeta-diversity emerging.

```{r code-env-data}
# Now comes in the in situ temperatures for the 58 coastal sections
# (interpolated temperaures as per version 2 of the South African Coastal Temperature Network):
load(here::here("data", "BCB743", "seaweed", "SeaweedEnv.RData"))

# I select only some of the thermal vars; the rest
# are collinear with some of the ones I import:
E1 <- dplyr::select(
  env,
  febMean,
  febRange,
  febSD,
  augMean,
  augRange,
  augSD,
  annMean,
  annRange,
  annSD
)

# Calculate z-scores:
E1 <- decostand(E1, method = "standardize")

# Load the coordinates of the coastal sections:
sites <- read.csv(here::here("data", "BCB743", "sites.csv"))
sites <- sites[, c(2, 1)]

# Load the bioregion definition:
bioreg <- read.csv(
  here::here("data", "BCB743", "seaweed", "bioregions.csv"),
  header = TRUE
)
```

## Preparation of Spatial Variables

I test the niche difference mechanism as the primary species compositional assembly process operating along South African shores. I suggest that the thermal gradient along the coast provides a suite of abiotic (thermal) conditions from which species can select based on their physiological tolerances, and hence this will structure \textbeta-diversity. For this mechanism to function one would assume that all species have equal access to all sections along this stretch of coast, thus following Beijerinck's 'Law' that everything is everywhere but the environment selects [@Sauer1988] (but see main text!).

The basic approach to a spatial analysis structured around a biological response (*e.g.*, community structure and composition; $Y$), environmental variables ($E$) and their spatial representation ($S$) involves an analysis of Moran's eigenvector maps (MEM), followed by db-RDA and variance partitioning. Various literature sources discuss principle behind Moran's eigenvector maps [@Dray2006; @Dray2012a]. Worked examples are also presented in the excellent book *Numerical Ecology with R* [@Borcard2011] in Section 7.4. The method followed here has been adapted from these and other sources.

Obtaining the MEMs to use in the analysis is based on the procedure introduced by Borcard and Legendre (2002), which was later modified by @Dray2006. The basic approach involves:

1. Set up a geographic or Euclidean distance matrix representing the pairwise distances between the $n$ sites ($D=[d_{ij}]$). I already did this when I applied the `decostand` function earlier.

2. Construct a truncated distance matrix by calculating a Minimum Spanning Tree ($S^{\star}$) and noting the following rules: $$S^{\star} =\left\{ \begin{array}{rl} 0 & \mbox{if}~i = j \\ d_{ij} & \mbox{if}~d_{ij} \leq t \\ 4t & \mbox{if}~d_{ij} > t \end{array} \right.$$ Weighting may be applied if desired, resulting in $S^{\star}_w$. It is not done here.

3. Do a Principal Coordinates Analysis (PCoA) of the truncated distance matrix $S^{\star}$.

The spatial properties imprinted on the species and their environment can be specified using a matrix of Euclidean or geographic distances. These coordinates are 'truncated' into a square (section $\times$ section) matrix containing non-negative values ($S^{\star}$). By convention the diagonal values are set to zero. A very basic spatial matrix is binary, where 1 codes for pairs of neighbouring sites while 0 denotes non-connected sites according to the chosen network topology. Such matrices are called 'binary connectivity matrices' and relate to graphs made using distance criteria derived from graph theory.

Truncation produced by Minimum Spanning Trees (MST) focuses on the binary relationships between neighbouring sites, discarding any other connections (*i.e.*, some sites are considered to be neighbours, while for others the relationships are null). One could also choose a Gabriel graph or another kind of network topology. Such matrix representations show section-to-section connectivities. In the case of South Africa's coastline data, the MST causes sections to be connected only to other sections adjacent to two sides of it: for example, Section **4** is directly connected to *only* Sections **3** and **5**; sections at the termini of the coastal 'string' of sections are each connected to only one other section. The binary connectivity matrices, also called *topology-based connectivity matrices*, can be produced from Euclidean or geographic coordinates using functions in at least two **R** packages (I start with geographic coordinates). One option is to use the **spdep** package's `mst.nb()` function to calculate a MST, but there are also options in the **vegan** package and elsewhere. The neighbours list arrived at from the MST represents the spatial component, $S^{\star}$. The MST results in small connectivity artefacts in the Saldanha Bay region where the closest sections are not necessarily the ones adjacent one-another following along the path around the coast, because sections at opposite sides of the bay may in fact be closer together. This topological inconsistency does not affect the spatial analysis in any way.

Once the truncated distance matrix has been prepared, it is subjected to a PCoA and I keep the eigenvectors that represent positive spatial correlation (positive Moran's $I$). For the MEM analysis I use the function `PCNM()` that resides in the `functions` folder in the file `PCNM.R` (see notes inside about authorship). PCNM stands for Principal Coordinates Analysis of Neighbourhood Matrices (the neighbourhood matrix in this instance being the MST). This method automatically constructs the spatial variables and calculates the Moran's I for each. The MEMs are completely orthogonal and represent the spatial structures over the full range of scales from 50 to 2,700 km. The large eigenvectors represent broad spatial scales while smaller ones cover finer features. The *spatial data* will be used as a set of explanatory variables in the multiple regression type analyses applied to a species dissimilarity matrix [*i.e.*, the db-RDA; @Dray2012a]

The code below reproduces the spatial analysis in the paper. Due to the length of the output I have prevented the script from returning any output here; rather, if the reader is for some odd reason interested in repeating this analysis, s/he may find the data and scripts in my [GitHub](https://github.com/ajsmit/Seaweed-beta) repository, and the full code can be run in its entirety. Well, I hope this will work, but if it does not (probably very likely) then write to me at [ajsmit\@uwc.ac.za](mailto:ajsmit@uwc.ac.za){.email} and I shall assist --- this may depend on if your email has a catchy title that will make it stand out from among all the other emails which other people think are equally important.

```{r code-pcnm}
#| fig-width: 8
#| fig-height: 4
#| fig.align: center

## Auto PCNM:
S.auto <- PCNM(dist(sites), silent = TRUE)
# summary(S.auto)

# The truncation distance:
S.dmin <- S.auto$thresh

# The number of eigenvalues:
S.len <- length(S.auto$values)

# Expected value of I, no spatial correlation:
S.auto$expected_Moran

# Select eigenfunction with positive spatial correlation:
S.sel <- which(S.auto$Moran_I$Positive == TRUE)
# length(S.sel)
# there are 27 MEMs, i.e. 27 of the PCNM variables (eigenvalues) relate
# significantly to Moran's I

# Extract the eigenvectors associated with those MEMs:
S.pos <- as.data.frame(S.auto$vectors)[, S.sel]
```

The code below lets us visualise the configuration of the 58 coastal sections as represented by the minimum spanning tree. Because the sites are constrained by the coast the MST network topology results in a string of coastal sections arranged along the shore between Section **1** and Section **58**. This spatial network therefore also captures the spatial connectivity in the seaweed's dispersal ability along the shore, although no directionality is associated with dispersal. In the paper I discuss the possible influence of ocean currents [*e.g.*, @Wernberg2013] and I pointed out that it is tempting to assume that seaweeds would disperse in the direction the major ocean currents. These kinds of networks could conceivably be configured to model dispersal due to currents, but here it is simply used for representing the spatial scale of the study region.

```{r fig-plot-mst}
#| fig-width: 8
#| fig-height: 4
#| fig.align: center

# The spatial netwwork topology of the coastal sections can be seen by:
plot(S.auto$spanning, sites)
```

## db-RDA on Moran's Eigenvector Maps

The next step of the spatial analysis is to apply a db-RDA with the seaweed data ($Y1$ and $Y2$) coupled with the MEMs. I now run a full (global) db-RDA on the significant, positive MEMs selected above, and I then perform a permutation test to see if the fit is significant.

```{r code-y1-pcnm-capscale-global}
# Run the db-RDA on the Y1 data:
S.Y1.cs <- capscale(Y1 ~ ., S.pos)

# Permutation test to test for the significance of the global fit:
anova(S.Y1.cs, parallel = 4) # ... yes, significant!

# The global adjusted R2 --- the variance explained by the constrained axes:
S.Y1.cs.R2 <- RsquareAdj(S.Y1.cs)$adj.r.squared

# Variance explained by full model:
sum(S.Y1.cs$CCA$eig) / S.Y1.cs$tot.chi * 100
```

```{r code-y2-pcnm-capscale-global}
# And on the Y2 data (uncommented, but same as above):
S.Y2.cs <- capscale(Y2 ~ ., S.pos)
S.Y2.cs.R2 <- RsquareAdj(S.Y2.cs)$adj.r.squared
sum(S.Y2.cs$CCA$eig) / S.Y2.cs$tot.chi * 100
```

**Initial analysis (pre-2017):** Since the analysis is significant, I compute the adjusted *R*^2^ and run forward selection of the MEMs. The forward selection procedure of @Blanchet2008 is implemented in the **packfor** package for R, and I use it to reduce the number of MEM variables and retain only those that best fit the biotic data. Forward selection prevents the inflation of the overall type I error and reduces the number of explanatory variables used in the final model, which improves parsimony. I then run a new db-RDA analysis on the 'best' (reduced) set of MEM variables that was selected.

```{r code-s-y1-fwd-forward}
#| eval: false
#| echo: false
# Forward selection on Y1:
S.Y1.fwd <- forward.sel(Y1, as.matrix(S.pos), adjR2thresh = S.Y1.cs.R2)

# Forward selection on Y2:
S.Y2.fwd <- forward.sel(Y2, as.matrix(S.pos), adjR2thresh = S.Y2.cs.R2)
```

```{r code-s-y1-no-sig}
#| eval: false
#| echo: false

# Write the significant MEMs to a new object:
S.Y1.no.sig <- nrow(S.Y1.fwd)
S.Y1.sign <- sort(S.Y1.fwd[, 2])
S.Y1.red <- S.pos[, c(S.Y1.sign)]
colnames(S.Y1.red) <- paste(
  rep("MEM", S.Y1.no.sig),
  as.character(S.Y1.sign),
  sep = ""
)

# Identity of significant MEMs:
colnames(S.Y1.red)

# Run a new db-RDA on the best MEM variables:
S.Y1.s2 <- capscale(Y1 ~ ., data = S.Y1.red)
# no need to check these for collinearity as the
# MEMs are completely orthogonal..

# Permutation test to test for significance:
anova(S.Y1.s2, parallel = 4)

# Test by axis:
anova(S.Y1.s2, by = "axis", parallel = 4)

# The significant axes:
S.Y1.axis.test <- anova(S.Y1.s2, by = "terms", parallel = 4)
S.Y1.ax <- which(S.Y1.axis.test[, 4] < 0.05)
S.Y1.sign.ax <- colnames(S.Y1.red[, S.Y1.ax])

# Test by terms:
anova(S.Y1.s2, by = "terms", parallel = 4)

# The adjusted R2 --- the variance explained by the constrained axes:
# S.Y1.s2.R2 <- RsquareAdj(S.Y1.s2)$adj.r.squared

# Variance explained by reduced model:
sum(S.Y1.s2$CCA$eig) / S.Y1.s2$tot.chi * 100

# Show only the first 6 rows:
scores(S.Y1.s2, display = "bp", choices = c(1:4))[1:6, ]
```

```{r code-s-y2-no-sig}
#| eval: false
#| echo: false

# As above, but now with Y2:
S.Y2.no.sig <- nrow(S.Y2.fwd)
S.Y2.sign <- sort(S.Y2.fwd[, 2])
S.Y2.red <- S.pos[, c(S.Y2.sign)]
colnames(S.Y2.red) <- paste(
  rep("MEM", S.Y2.no.sig),
  as.character(S.Y2.sign),
  sep = ""
)
colnames(S.Y2.red)
S.Y2.s2 <- capscale(Y2 ~ ., data = S.Y2.red)

anova(S.Y2.s2, parallel = 4) # ... yes, significant!

anova(S.Y2.s2, by = "axis", parallel = 4)

S.Y2.axis.test <- anova(S.Y2.s2, by = "terms", parallel = 4)
S.Y2.ax <- which(S.Y2.axis.test[, 4] < 0.05)
S.Y2.sign.ax <- colnames(S.Y2.red[, S.Y2.ax])

S.Y2.s2.R2 <- RsquareAdj(S.Y2.s2)$adj.r.squared

sum(S.Y2.s2$CCA$eig) / S.Y2.s2$tot.chi * 100

scores(S.Y2.s2, display = "bp", choices = c(1:4))
```

**Update (2024):** The **packfor** package is no longer available so I have updated my methods to use **vegan**'s `ordiR2step()` function instead. This function is a stepwise model selection procedure that uses adjusted *R*^2^ as the criterion (as in **packfor**) for selecting the best model. I run the forward selection procedure on the full model and retain the significant ('best', reduced) MEMs in the final model. I then use only the retained MEMs in subsequent steps.

```{r code-s-y1-cs-null}
# Run the db-RDA on the Y1 data:
S.Y1.cs.null <- capscale(Y1 ~ 1, S.pos) # a null model
S.Y1.cs <- capscale(Y1 ~ ., S.pos)

S.Y1.fwd <- ordiR2step(S.Y1.cs.null, S.Y1.cs, trace = FALSE)

# the significant MEMs to retain are
as.data.frame(S.Y1.fwd$anova)
S.Y1.red <- S.pos[, row.names(as.data.frame(scores(S.Y1.fwd)$biplot))]
names(S.Y1.red) <- sub("^V", "MEM", names(S.Y1.red)) # rename them
```

```{r code-s-y2-cs-null}
# Run the db-RDA on the Y2 data:
S.Y2.cs.null <- capscale(Y2 ~ 1, S.pos) # a null model
S.Y2.cs <- capscale(Y2 ~ ., S.pos)

S.Y2.fwd <- ordiR2step(S.Y2.cs.null, S.Y2.cs, trace = FALSE)

# the significant MEMs to retain are
as.data.frame(S.Y2.fwd$anova)
S.Y2.red <- S.pos[, row.names(as.data.frame(scores(S.Y2.fwd)$biplot))]
names(S.Y2.red) <- sub("^V", "MEM", names(S.Y2.red)) # rename them
```

Now I run a new db-RDA analysis on the 'best' (reduced) set of MEM variables that was selected. 

```{r code-y1-pcnm-capscale-final}
# Run a new db-RDA on the best MEM variables:
S.Y1.s2 <- capscale(Y1 ~ ., data = S.Y1.red)
# no need to check these for collinearity as the
# MEMs are completely orthogonal..

# Permutation test to test for significance:
anova(S.Y1.s2, parallel = 4)

# Test by axis:
anova(S.Y1.s2, by = "axis", parallel = 4)

# The significant axes:
S.Y1.axis.test <- anova(S.Y1.s2, by = "terms", parallel = 4)
S.Y1.ax <- which(S.Y1.axis.test[, 4] < 0.05)
S.Y1.sign.ax <- colnames(S.Y1.red[, S.Y1.ax])

# Test by terms:
anova(S.Y1.s2, by = "terms", parallel = 4)

# The adjusted R2 --- the variance explained by the constrained axes:
# S.Y1.s2.R2 <- RsquareAdj(S.Y1.s2)$adj.r.squared

# Variance explained by reduced model:
sum(S.Y1.s2$CCA$eig) / S.Y1.s2$tot.chi * 100

# Show only the first 6 rows:
scores(S.Y1.s2, display = "bp", choices = c(1:4))[1:6, ]
```

```{r code-y2-pcnm-capscale-final}
S.Y2.s2 <- capscale(Y2 ~ ., data = S.Y2.red)

anova(S.Y2.s2, parallel = 4) # ... yes, significant!
anova(S.Y2.s2, by = "axis", parallel = 4)

S.Y2.axis.test <- anova(S.Y2.s2, by = "terms", parallel = 4)
S.Y2.ax <- which(S.Y2.axis.test[, 4] < 0.05)
S.Y2.sign.ax <- colnames(S.Y2.red[, S.Y2.ax])
S.Y2.s2.R2 <- RsquareAdj(S.Y2.s2)$adj.r.squared
sum(S.Y2.s2$CCA$eig) / S.Y2.s2$tot.chi * 100
scores(S.Y2.s2, display = "bp", choices = c(1:4))
```

## A Few Visualisations

Now I make a visualisation to reveal the spatial arrangement of the MEMs used in the final db-RDA involving the spatial variables (*i.e.*, \texttt{S.Y1.s2} and \texttt{S.Y2.s2}). The spatial configuration relates to broad scales as seen in Fig. 3 in the paper. Here are plots of the site scores for the MEMs and $Y1$ and $Y2$ (a few panels belonging with Fig. 3):

```{r code-y1-y2-sa-score-plot}
# Plot the first canonical axis of the db-RDA with the significant MEMs for Y1;
# (see Fig. 3):
S.Y1.axes <- scores(S.Y1.s2, choices = c(1:3), display = "lc", scaling = 1)
S.Y1.plt.axis1 <- ggmap() +
  geom_point(
    data = sites,
    aes(
      x = Longitude,
      y = Latitude,
      size = abs(S.Y1.axes[, 1]),
      col = ifelse(S.Y1.axes[, 1] < 0, "a", "b")
    ),
    shape = 1
  ) +
  scale_size_continuous(guide = FALSE) +
  scale_colour_manual(guide = "none", values = c("black", "grey60")) +
  ggtitle(expression(paste("CAP1 of spatial variables, ", beta[sim])))

# And the same for Y2 (see Fig. 3):
S.Y2.axes <- scores(S.Y2.s2, choices = c(1:3), display = "lc", scaling = 1)
S.Y2.plt.axis1 <- ggmap() +
  geom_point(
    data = sites,
    aes(
      x = Longitude,
      y = Latitude,
      size = abs(S.Y2.axes[, 1]),
      col = ifelse(S.Y2.axes[, 1] < 0, "a", "b")
    ),
    shape = 1
  ) +
  scale_size_continuous(guide = FALSE) +
  scale_colour_manual(guide = "none", values = c("black", "grey60")) +
  ggtitle(expression(paste("CAP1 of spatial variables, ", beta[sne])))
```

Now that I know that spatial structures are present in the seaweed data I check how these significant spatial patterns (two significant canonical axes, CAP1 and CAP2) are related to the environmental variables using linear regression. Checks for normality are also done but none of the output is printed here.

Next I want to show the ordination biplots of the MEM variables with respect to the sites using scaling = 2 (species) and showing the LC scores. Now I can see the major directions of influence of the spatial variables with respect to the sites. The code below produces a few panels of Fig. 2 (the figure is reproduced at the end of this document):

```{r fig-y1-y2-spatial-ordiplot}
# A few of the panels that go with Fig. 2;
# first for Y1...:
S.Y1.scrs <- scores(S.Y1.s2, display = c("sp", "wa", "lc", "bp", "cn"))
S.Y1.df_sites <- data.frame(S.Y1.scrs$constraints)
S.Y1.df_sites$bioreg <- bioreg$bolton
S.Y1.df_sites$section <- seq(1:58)
colnames(S.Y1.df_sites) <- c("x", "y", "Bioregion", "Section")

multiplier <- ordiArrowMul(S.Y1.scrs$biplot)
S.Y1.bp <- S.Y1.scrs$biplot * multiplier
S.Y1.bp <- as.data.frame(S.Y1.bp)
S.Y1.bp$labels <- rownames(S.Y1.bp)
colnames(S.Y1.bp) <- c("x", "y", "labels")
S.Y1.bp.sign <- S.Y1.bp[S.Y1.bp$labels %in% S.Y1.sign.ax, ]

# A modification of the vegan ordiArrowTextXY() function to prevent the
# "plot.new has not been called yet" from occurring
source(here::here("R", "text_mult.R"))

S.Y1.text <- text.mult(S.Y1.scrs$biplot)
S.Y1.text <- as.data.frame(S.Y1.text)
S.Y1.text$labels <- rownames(S.Y1.text)
colnames(S.Y1.text) <- c("x", "y", "labels")
S.Y1.text.sign <- S.Y1.text[S.Y1.text$labels %in% S.Y1.sign.ax, ]

S.Y1.p <- ggplot(data = S.Y1.df_sites, aes(x, y, colour = Bioregion)) +
  geom_point(size = 4.0) +
  geom_text(aes(label = Section), size = 3.0, col = "white") +
  geom_segment(
    data = S.Y1.bp,
    aes(x = 0, y = 0, xend = x, yend = y),
    arrow = arrow(length = unit(0.2, "cm")),
    colour = "red",
    alpha = 1,
    size = 0.7
  ) +
  geom_text(
    data = as.data.frame(S.Y1.text),
    aes(x, y, label = rownames(S.Y1.text)),
    colour = "black"
  ) +
  xlab("CAP1") +
  ylab("CAP2") +
  ggtitle(expression(paste("Spatial variables and ", beta[sim]))) +
  theme_grey() +
  theme(
    panel.grid.minor = element_blank(),
    legend.position = "none",
    aspect.ratio = 0.8
  )

# ...then for Y2:
S.Y2.scrs <- scores(S.Y2.s2, display = c("sp", "wa", "lc", "bp", "cn"))
S.Y2.df_sites <- data.frame(S.Y2.scrs$constraints)
S.Y2.df_sites$bioreg <- bioreg$bolton
S.Y2.df_sites$section <- seq(1:58)
colnames(S.Y2.df_sites) <- c("x", "y", "Bioregion", "Section")

multiplier <- ordiArrowMul(S.Y2.scrs$biplot, fill = 0.25)
S.Y2.bp <- S.Y2.scrs$biplot * multiplier
S.Y2.bp <- as.data.frame(S.Y2.bp)
S.Y2.bp$labels <- rownames(S.Y2.bp)
colnames(S.Y2.bp) <- c("x", "y", "labels")
S.Y2.bp.sign <- S.Y2.bp[S.Y2.bp$labels %in% S.Y2.sign.ax, ]

S.Y2.text <- text.mult(S.Y2.scrs$biplot, fill = 0.25)
S.Y2.text <- as.data.frame(S.Y2.text)
S.Y2.text$labels <- rownames(S.Y2.text)
colnames(S.Y2.text) <- c("x", "y", "labels")
S.Y2.text.sign <- S.Y2.text[S.Y2.text$labels %in% S.Y2.sign.ax, ]

S.Y2.p <- ggplot(data = S.Y2.df_sites, aes(x, y, colour = Bioregion)) +
  geom_point(size = 4.0) +
  geom_text(aes(label = Section), size = 3.0, col = "white") +
  geom_segment(
    data = S.Y2.bp.sign,
    aes(x = 0, y = 0, xend = x, yend = y),
    arrow = arrow(length = unit(0.2, "cm")),
    colour = "red",
    alpha = 1,
    size = 0.7
  ) +
  geom_text(
    data = as.data.frame(S.Y2.text.sign),
    aes(x, y, label = rownames(S.Y2.text.sign)),
    colour = "black"
  ) +
  xlab("CAP1") +
  ylab("CAP2") +
  ggtitle(expression(paste("Spatial variables and ", beta[sne]))) +
  theme_grey() +
  theme(
    panel.grid.minor = element_blank(),
    legend.position = "none",
    aspect.ratio = 0.8
  )
```

## Analysis of the Thermal Variables

As before with the spatial variable, I now do a db-RDA involving all the thermal variables ($E$) followed by forward selection. There is less explanation provided here as the reader should now be familiar with db-RDA --- the procedure is the same as with the MEMs, just different explanatory variables are supplied. Another difference is that the thermal variables are not necessarily orthogonal, so I check for collinearity using variance inflation factors (VIF).

I start with the full model and then run forward selection and repeat the db-RDA on the reduced set. Analyses shown for $Y1$ and $Y2$:

```{r code-y1-env-capscale-global}
# First Y1:
E.Y1.cs <- capscale(Y1 ~ ., E1)

# Is the fit significant?
anova(E.Y1.cs, parallel = 4) # ... yes!

# The adjusted R2 --- the variance explained by the constrained axes:
E.Y1.R2a <- RsquareAdj(E.Y1.cs)$adj.r.squared

# Variance explained by full model:
sum(E.Y1.cs$CCA$eig) / E.Y1.cs$tot.chi * 100
```

```{r code-y2-env-capscale-global}
# ...and now Y2:
E.Y2.cs <- capscale(Y2 ~ ., E1)
anova(E.Y2.cs, parallel = 4) # ... yes!
E.Y2.R2a <- RsquareAdj(E.Y2.cs)$adj.r.squared
sum(E.Y2.cs$CCA$eig) / E.Y2.cs$tot.chi * 100
```

```{r code-e-y1-fwd-forward}
#| echo: false
#| eval: false
# Forward selection on Y1:
E.Y1.fwd <- forward.sel(Y1, E1, adjR2thresh = E.Y1.R2a, nperm = 999)

# Forward selection on Y1:
E.Y2.fwd <- forward.sel(Y2, E1, adjR2thresh = E.Y2.R2a, nperm = 999)
```

```{r code-y1-y2-env-forward-select-final}
# Forward selection on Y1:
# Run the db-RDA on the Y1 data:
E.Y1.cs.null <- capscale(Y1 ~ 1, E1) # a null model

# Forward selection on Y1:
E.Y1.fwd <- ordiR2step(E.Y1.cs.null, E.Y1.cs, trace = FALSE)
E.Y1.fwd$anova
```

```{r code-e-y2-cs-null}
# Now Y2:
E.Y2.cs.null <- capscale(Y2 ~ 1, E1) # a null model
E.Y2.fwd <- ordiR2step(E.Y2.cs.null, E.Y2.cs, trace = FALSE)
E.Y2.fwd$anova
```

```{r code-y1-env-capscale-final}
# Write the significant envs to a new object, and
# identity of significant envs in increasing order;
# first Y1:
E.Y1.sign <- row.names(as.data.frame(scores(E.Y1.fwd)$biplot))

E.Y1.red <- E1[, E.Y1.sign]

# Run a new env analysis on the best env variables:
E.Y1.cs2 <- capscale(Y1 ~ ., E.Y1.red)

# Check for collinearity:
vif.cca(E.Y1.cs2) # seems fine

# Test for significance:
anova(E.Y1.cs2, parallel = 4) # ... yes!

# Which axes are significant?
anova(E.Y1.cs2, by = "axis", parallel = 4) # ... yes!

# The significant axes:
E.Y1.axis.test <- anova(E.Y1.cs2, by = "terms", parallel = 4)
E.Y1.ax <- which(E.Y1.axis.test[, 4] < 0.05)
E.Y1.sign.ax <- colnames(E.Y1.red[, E.Y1.ax])

# The adjusted R2 --- the variance explained by the constrained axes:
E.Y1.cs2.R2 <- RsquareAdj(E.Y1.cs2)$adj.r.squared

# Variance explained by reduced (final) model:
sum(E.Y1.cs2$CCA$eig) / E.Y1.cs2$tot.chi * 100

# The biplot scores for constraining variables:
scores(E.Y1.cs2, display = "bp", choices = c(1:2))
```

```{r code-y2-env-capscale-final}
# ...then Y2
E.Y2.sign <- row.names(as.data.frame(scores(E.Y2.fwd)$biplot))
E.Y2.red <- E1[, E.Y2.sign]

E.Y2.cs2 <- capscale(Y2 ~ ., E.Y2.red)

vif.cca(E.Y2.cs2) # seems fine

anova(E.Y2.cs2, parallel = 4) # ... yes!

E.Y2.axis.test <- anova(E.Y2.cs2, by = "terms", parallel = 4)
# E.Y2.ax <- which(E.Y2.axis.test[, 4] < 0.05) # doesn't work...
# E.Y2.sign.ax <- colnames(E.Y2.red[,E.Y2.ax])
E.Y2.sign.ax <- "annMean" # a manual cheat

anova(E.Y2.cs2, by = "terms", parallel = 4) # ... yes!

E.Y2.cs2.R2 <- RsquareAdj(E.Y2.cs2)$adj.r.squared

sum(E.Y2.cs2$CCA$eig) / E.Y2.cs2$tot.chi * 100

scores(E.Y2.cs2, display = "bp", choices = c(1:2))
```

Now I make the remaining panels of Fig. 3, these showing the spatial arrangement associated with the site scores of the environmental variables for $Y1$ and $Y2$:

```{r code-y1-y2-sa-env-score-plot}
# Plot the two significant canonical axes of the
# db-RDA with the significant MEMs. This part of Fig. 3:
E.Y1.axes <- scores(E.Y1.cs2, choices = c(1:2), display = "lc", scaling = 1)
E.Y1.plt.axis1 <- ggmap() +
  geom_point(
    data = sites,
    aes(x = Longitude, y = Latitude, size = E.Y1.axes[, 1]),
    col = "black",
    shape = 1
  ) +
  scale_size_continuous(guide = "none") +
  ggtitle(expression(paste("CAP1 of thermal variables, ", beta[sim])))

E.Y1.plt.axis2 <- ggmap() +
  geom_point(
    data = sites,
    aes(x = Longitude, y = Latitude, size = E.Y1.axes[, 2]),
    col = "black",
    shape = 1
  ) +
  scale_size_continuous(guide = "none") +
  ggtitle(expression(paste("CAP2 of thermal variables, ", beta[sim])))

E.Y2.axes <- scores(E.Y2.cs2, choices = c(1:3), display = "lc", scaling = 1)

E.Y2.plt.axis1 <- ggmap() +
  geom_point(
    data = sites,
    aes(x = Longitude, y = Latitude, size = E.Y2.axes[, 1]),
    col = "black",
    shape = 1
  ) +
  scale_size_continuous(guide = "none") +
  ggtitle(expression(paste("CAP1 of thermal variables, ", beta[sne])))
```

And now I make the remaining panels of Fig. 2 (below) for Y1 and Y2 and the environmental constraining vectors:

```{r fig-y1-env-ordiplot}
# The ordiplots in Fig. 2:
E.Y1.scrs <- scores(E.Y1.cs2, display = c("sp", "wa", "lc", "bp", "cn"))
E.Y1.df_sites <- data.frame(E.Y1.scrs$constraints)
E.Y1.df_sites$bioreg <- bioreg$bolton
E.Y1.df_sites$section <- seq(1:58)
colnames(E.Y1.df_sites) <- c("x", "y", "Bioregion", "Section")

multiplier <- ordiArrowMul(E.Y1.scrs$biplot)
E.Y1.bp <- E.Y1.scrs$biplot * multiplier
E.Y1.bp <- as.data.frame(E.Y1.bp)
E.Y1.bp$labels <- rownames(E.Y1.bp)
colnames(E.Y1.bp) <- c("x", "y", "labels")
E.Y1.bp.sign <- E.Y1.bp[E.Y1.bp$labels %in% E.Y1.sign.ax, ]

E.Y1.text <- text.mult(E.Y1.scrs$biplot)
E.Y1.text <- as.data.frame(E.Y1.text)
E.Y1.text$labels <- rownames(E.Y1.text)
colnames(E.Y1.text) <- c("x", "y", "labels")
E.Y1.text.sign <- E.Y1.text[E.Y1.text$labels %in% E.Y1.sign.ax, ]

E.Y1.p <- ggplot(data = E.Y1.df_sites, aes(x, y, colour = Bioregion)) +
  geom_point(size = 4.0) +
  geom_text(aes(label = Section), size = 3.0, col = "white") +
  geom_segment(
    data = E.Y1.bp.sign,
    aes(x = 0, y = 0, xend = x, yend = y),
    arrow = arrow(length = unit(0.2, "cm")),
    colour = "red",
    alpha = 1,
    size = 0.7
  ) +
  geom_text(
    data = as.data.frame(E.Y1.text.sign),
    aes(x, y, label = rownames(E.Y1.text.sign)),
    colour = "black"
  ) +
  xlab("CAP1") +
  ylab("CAP2") +
  ggtitle(expression(paste("Thermal variables and ", beta[sim]))) +
  theme_grey() +
  theme(
    panel.grid.minor = element_blank(),
    legend.position = "none",
    aspect.ratio = 0.8
  )

E.Y2.scrs <- scores(E.Y2.cs2, display = c("sp", "wa", "lc", "bp", "cn"))
E.Y2.df_sites <- data.frame(E.Y2.scrs$constraints)
E.Y2.df_sites$bioreg <- bioreg$bolton
E.Y2.df_sites$section <- seq(1:58)
colnames(E.Y2.df_sites) <- c("x", "y", "Bioregion", "Section")

multiplier <- ordiArrowMul(E.Y2.scrs$biplot, fill = 0.45)
E.Y2.bp <- E.Y2.scrs$biplot * multiplier
E.Y2.bp <- as.data.frame(E.Y2.bp)
E.Y2.bp$labels <- rownames(E.Y2.bp)
colnames(E.Y2.bp) <- c("x", "y", "labels")
E.Y2.bp.sign <- E.Y2.bp[E.Y2.bp$labels %in% E.Y2.sign.ax, ]

E.Y2.text <- text.mult(E.Y2.scrs$biplot, fill = 0.45)
E.Y2.text <- as.data.frame(E.Y2.text)
E.Y2.text$labels <- rownames(E.Y2.text)
colnames(E.Y2.text) <- c("x", "y", "labels")
E.Y2.text.sign <- E.Y2.text[E.Y2.text$labels %in% E.Y2.sign.ax, ]

E.Y2.p <- ggplot(data = E.Y2.df_sites, aes(x, y, colour = Bioregion)) +
  geom_point(size = 4.0) +
  geom_text(aes(label = Section), size = 3.0, col = "white") +
  geom_segment(
    data = E.Y2.bp.sign,
    aes(x = 0, y = 0, xend = x, yend = y),
    arrow = arrow(length = unit(0.2, "cm")),
    colour = "red",
    alpha = 1,
    size = 0.7
  ) +
  geom_text(
    data = as.data.frame(E.Y2.text.sign),
    aes(x, y, label = rownames(E.Y2.text.sign)),
    colour = "black"
  ) +
  xlab("CAP1") +
  ylab("CAP2") +
  ggtitle(expression(paste("Thermal variables and ", beta[sne]))) +
  theme_grey() +
  theme(
    panel.grid.minor = element_blank(),
    legend.position.inside = c(.80, .75),
    aspect.ratio = 0.8
  )
```

Here I now assemble the various panels into what we see produced in Fig. 2 in the paper:

```{r code-make-fig-2a-d}
#| fig-width: 10
#| fig-height: 8.25
#| fig.align: center

ggarrange(
  E.Y1.p,
  E.Y2.p,
  S.Y1.p,
  S.Y2.p,
  ncol = 2,
  nrow = 2,
  labels = "AUTO",
  common.legend = TRUE,
  legend = "top"
)
```

And I do the same with assembling the panels that form Fig. 3 in the paper:

```{r fn-make-fig-3a-e}
#| fig-width: 10
#| fig-height: 10
#| fig.align: center

grid::grid.newpage()
grid::pushViewport(grid::viewport(layout = grid::grid.layout(3, 2)))
vplayout <- function(x, y) {
  grid::viewport(layout.pos.row = x, layout.pos.col = y)
}
print(E.Y1.plt.axis1, vp = vplayout(1, 1))
print(E.Y1.plt.axis2, vp = vplayout(1, 2))
print(E.Y2.plt.axis1, vp = vplayout(2, 1))
print(S.Y1.plt.axis1, vp = vplayout(3, 1))
print(S.Y2.plt.axis1, vp = vplayout(3, 2))
```

::: callout-note
## **MEMs and Their Interpretation**

MEMs (Moran's Eigenvector Maps) are spatial variables used to represent different scales of spatial structure in spatial ecological data. They accomplish the following:

1. Account for spatial autocorrelation that might be present due to the nature of ecological processes and geographic proximity of sampling sites (processes at a specific site might be affected by nearly processes, but less so by processes operating further away).
2. Capture and model spatial patterns that may not be directly accounted for by measured environmental variables.
3. Separate the effects of pure spatial processes from pure environmental influences on species distributions.

In this instance, the MEMs were made from a spatial connectivity matrix that considered the geographic relationships between sampling sites. Here, I used a minimum spanning tree (MST) topology to focus on connections between neighbouring coastal sections.

The insights MEMs provide are:

1. Modelling spatial structures at multiple scales, from broad (large eigenvectors) to fine (smaller eigenvectors).
2. Identify spatially structured patterns in species communities that may be due to factors beyond measured environmental variables.
3. Assist with partitioning of variation in community composition into purely spatial, purely environmental, and spatially structured environmental components.

The bottom panels (with the spatial structures captured by the MEMs) show the Canonical Analysis of Principal Coordinates (CAP1) of spatial variables for $\beta_{sim}$ (species turnover) and $\beta_{sne}$ (nestedness). We see that:

1. There is a strong spatial gradient along the coast, as indicated by the change in circle size and shading from west to east.
2. The spatial pattern is similar for both $\beta_{sim}$ and $\beta_{sne}$, which suggests that both components of $\beta$-diversity have a strong spatial structure.
3. The western and eastern ends of the coast show the most distinct spatial patterns (larger circles), indicating stronger spatial effects in these areas.
4. The middle section of the coast shows smaller circles, suggesting weaker spatial effects or more homogeneous communities in this region.
5. The differences in patterns between $\beta_{sim}$ and $\beta_{sne}$ suggests that nestedness (neutral-processes) are quite prominent along the west coast.
:::

## Partitioning of Variance

Lastly, using **vegan**'s `varpart()` function, I partition the variance between the MEM variables and the thermal variables [@Peres-Neto2006; @PeresNeto2010].

```{r fig-y1-y2-varpart}
#| fig-width: 8
#| fig-height: 4
#| fig.align: center

# These lines of code produce a few figures to visually understand
# the variance partitioning on Y1:
vp2.Y1 <- varpart(Y1, E.Y1.red, S.Y1.red)
par(mfrow = c(1, 2))
showvarparts(2, c("Environ-\nment", "", "Spatial", ""))
plot(vp2.Y1, digits = 2)
par(mfrow = c(1, 1))

# Now I test the significant fractions [a], [b] and [c]...
ES.Y1.red <- cbind(E.Y1.red, S.Y1.red)

# Fraction E | S; pure environmental, i.e. [a]:
anova.cca(
  capscale(
    Y1 ~
      augMean +
        febRange +
        febSD +
        augSD +
        Condition(
          MEM1 +
            MEM2 +
            MEM3 +
            MEM4 +
            MEM5 +
            MEM6 +
            MEM7 +
            MEM8 +
            MEM9 +
            MEM10 +
            MEM13 +
            MEM15 +
            MEM16 +
            MEM18 +
            MEM19 +
            MEM20
        ),
    data = ES.Y1.red
  ),
  parallel = 4,
  step = 1000
)

# Fraction S | E; pure spatial, i.e. [c]:
anova.cca(
  capscale(
    Y1 ~
      MEM1 +
        MEM2 +
        MEM3 +
        MEM4 +
        MEM5 +
        MEM6 +
        MEM7 +
        MEM8 +
        MEM9 +
        MEM10 +
        MEM13 +
        MEM15 +
        MEM16 +
        MEM18 +
        MEM19 +
        MEM20 +
        Condition(augMean + febRange + febSD + augSD),
    data = ES.Y1.red
  ),
  parallel = 4,
  step = 1000
)

# Fraction E; environmental, i.e. [a] + [b]:
anova.cca(capscale(Y1 ~ ., E.Y1.red), parallel = 4, step = 1000)

# Fractions S; spatial, i.e. [b] + [c]:
anova.cca(capscale(Y1 ~ ., S.Y1.red), parallel = 4, step = 1000)

# Fractions E + S; spatial and environmental, i.e. [a] + [b] + [c]:
anova.cca(
  capscale(Y1 ~ ., cbind(E.Y1.red, S.Y1.red)),
  parallel = 4,
  step = 1000
)

# And now the partitioning of the variance in Y2:
(vp2.Y2 <- varpart(Y2, E.Y2.red, S.Y2.red))
par(mfrow = c(1, 2))
showvarparts(2, c("Environ-\nment", "", "Spatial", ""))
plot(vp2.Y2, digits = 2)
par(mfrow = c(1, 1))

# Tests the significant fractions [a], [b] and [c]...
ES.Y2.red <- cbind(E.Y2.red, S.Y2.red)

# Fraction E | S; pure environmental, i.e. [a]:
anova.cca(
  capscale(
    Y2 ~
      annMean +
        Condition(MEM1 + MEM2 + MEM3 + MEM5),
    data = ES.Y2.red
  ),
  parallel = 4,
  step = 1000
)

# Fraction S | E; pure spatial, i.e. [c]:
anova.cca(
  capscale(
    Y2 ~ MEM1 + MEM2 + MEM3 + MEM5 + Condition(annMean),
    data = ES.Y2.red
  ),
  parallel = 4,
  step = 1000
)

# Fraction E; environmental, i.e. [a] + [b]:
anova.cca(capscale(Y2 ~ ., E.Y2.red), parallel = 4, step = 1000)

# Fractions S; spatial, i.e. [b] + [c]:
anova.cca(capscale(Y2 ~ ., S.Y2.red), parallel = 4, step = 1000)

# Fractions E + S; spatial and environmental, i.e. [a] + [b] + [c]:
anova.cca(
  capscale(Y2 ~ ., cbind(E.Y2.red, S.Y2.red)),
  parallel = 4,
  step = 1000
)
```

## Network Graphs of $\beta$-Diversity

This is Appendix C of the paper @smit2017seaweeds.

I delved deeper into the patterns of \textbeta-diversity by examining the properties of the full dissimilarity matrix, which gives regional \textbeta-diversity mentioned above. This matrix describes all pairwise combinations of sections (582 --- 1 = 3363), and as such gives us a regional perspective [@Anderson2013].

The usual visualisation approach is to plot the dissimilarity metric as a function of geographical distance along the gradient or with respect to the distance between corresponding pairs of sections [*e.g.*, @Nekola1999; @Davidar2007]; these visualisations are provided here. The plots of dissimilarities were colour-coded according to the bioregion to which the section pairs belong (the Benguela Marine Province (BMP; **1**--**17**), the Benguela-Agulhas Transition Zone (B-ATZ; **18**--**22**), the Agulhas Marine Province (AMP; **19**--**43**/**44** --- the location of this transition is somewhat uncertain at this stage), and the East Coast Transition Zone (ECTZ; **44**/**45**--**58**) [*sensu* @Bolton2004] to distinguish bioregional properties of species distribution from the wider geographical scale structure along the whole coastline.

In doing so, the change in $\beta$-diversity per unit of separating distance between sections (km^-1^) could be calculated for each bioregion using linear regression. Since the connectivity between sections is constrained by their location along the shore, I calculated the distances between sections not as 'as the crow ﬂies' distances (*e.g.*, Section **1** is not connected in a straight line to Section **58** because of the intervening land in-between), but as the great circle geodesic distances between each pair of sections along a network of connected sections (vertices on a network graph). In other words, travelling from Section **1** to Section **58** requires travelling first along the coast through Section **2**, then Section **3**, and eventually all the way up to Section **58**. The total distance between a pair of arbitrary sections is therefore the cumulative sum of the great circle distances between each consecutive pair of intervening sections along the 'route'. This information is encapsulated as a square geodesic distance matrix, and can supply the distance along the abscissa against which species dissimilarities are plotted along the ordinate. The plots showing the relationship between \textbeta-diversity with distance are limited because they do not provide a geographical context.

To overcome this problem, I relied on a visualisation technique not commonly found in biogeographical studies to explicitly provide the geographical context. I structured the sections as vertices of a network graph and assigned to them their geographical coordinates to force a familiar layout of the graph --- when plotted on geographic coordinates, the sections form a map of South Africa. The species dissimilarities were assigned as edge weights (the lines connecting the **58** coastal sections) between pairs of sections and added to the map. The weights are directly proportional to the thickness of the edges and colours assigned to vertices (points or the 58 coastal sections) cluster the sections into their bioregions. Initially I used the **igraph** package that many people rave about, but I found it bothersome. So I devised a cunning way to create network graphs from scratch with some **dplyr** and **ggplot2** magic. I suppose that if I really wanted to I could have made neat functions here (and elsewhere) to reduce some of the repetitive nature of my code, but I really could not be bother doing that.

```{r fn-network-graphs}
#| fig-width: 10
#| fig-height: 7
#| fig.align: center

# Visualise the pairwise dissimilarities as network graphs where the
# vertices are geographical coordinates and the edge lengths are the geodesic
# distances.
# These visualisations appear in the paper as Fig. 4.
colnames(sites) <- c("lon", "lat")
sites <- cbind(data.frame(site = seq(1:58)), sites)

Y1.sl <- as.data.frame(expand.grid(seq(1:58), seq(1:58)))
colnames(Y1.sl) <- c("to", "from")

Y2.sl <- Y1.sl

# First Y1:
Y1.sl$Y1 <- as.vector(Y1)

Y1.sl.BMP <- Y1.sl %>%
  dplyr::left_join(., sites, by = c("to" = "site")) %>%
  dplyr::left_join(., sites, by = c("from" = "site")) %>%
  dplyr::filter(Y1 <= 0.5 & Y1 != 0) %>%
  dplyr::filter(from != to & from <= 16)

Y1.sl.BATZ <- Y1.sl %>%
  dplyr::left_join(., sites, by = c("to" = "site")) %>%
  dplyr::left_join(., sites, by = c("from" = "site")) %>%
  dplyr::filter(Y1 <= 0.5 & Y1 != 0) %>%
  dplyr::filter(from != to & from > 16 & from <= 21)

Y1.sl.AMP <- Y1.sl %>%
  dplyr::left_join(., sites, by = c("to" = "site")) %>%
  dplyr::left_join(., sites, by = c("from" = "site")) %>%
  dplyr::filter(Y1 <= 0.5 & Y1 != 0) %>%
  dplyr::filter(from != to & from > 21 & from <= 41)

Y1.sl.ECTZ <- Y1.sl %>%
  dplyr::left_join(., sites, by = c("to" = "site")) %>%
  dplyr::left_join(., sites, by = c("from" = "site")) %>%
  dplyr::filter(Y1 <= 0.5 & Y1 != 0) %>%
  dplyr::filter(from != to & from > 41)

Y1.sl <- rbind(Y1.sl.BMP, Y1.sl.BATZ, Y1.sl.AMP, Y1.sl.ECTZ)

# and then Y2:
Y2.sl$Y2 <- as.vector(Y2)

Y2.sl.BMP <- Y2.sl %>%
  dplyr::left_join(., sites, by = c("to" = "site")) %>%
  dplyr::left_join(., sites, by = c("from" = "site")) %>%
  dplyr::filter(Y2 <= 0.5 & Y2 != 0) %>%
  dplyr::filter(from != to & from <= 16)

Y2.sl.BATZ <- Y2.sl %>%
  dplyr::left_join(., sites, by = c("to" = "site")) %>%
  dplyr::left_join(., sites, by = c("from" = "site")) %>%
  dplyr::filter(Y2 <= 0.5 & Y2 != 0) %>%
  dplyr::filter(from != to & from > 16 & from <= 21)

Y2.sl.AMP <- Y2.sl %>%
  dplyr::left_join(., sites, by = c("to" = "site")) %>%
  dplyr::left_join(., sites, by = c("from" = "site")) %>%
  dplyr::filter(Y2 <= 0.5 & Y2 != 0) %>%
  dplyr::filter(from != to & from > 21 & from <= 41)

Y2.sl.ECTZ <- Y2.sl %>%
  dplyr::left_join(., sites, by = c("to" = "site")) %>%
  dplyr::left_join(., sites, by = c("from" = "site")) %>%
  dplyr::filter(Y2 <= 0.5 & Y2 != 0) %>%
  dplyr::filter(from != to & from > 41)

# Load coastline
load(here::here("data", "BCB743", "coast.RData"))

sa_lats <- c(-38, -26)
sa_lons <- c(14, 34)

net.plot.Y1 <- function(dissim = NULL, title = NULL, col.seq = NULL) {
  ggplot(dissim, aes(lon.x, lat.x)) +
    geom_polygon(
      data = south_africa_coast,
      aes(x = long, y = lat, group = group),
      show.legend = FALSE,
      fill = "#F9FAEC"
    ) +
    geom_curve(
      aes(xend = lon.y, yend = lat.y, col = Y1, alpha = (1 - Y1) - 0.4),
      curvature = 0.3
    ) +
    geom_point(
      data = sites,
      aes(x = lon, y = lat, fill = bioreg$bolton),
      col = "black",
      shape = 21
    ) +
    scale_fill_manual(
      breaks = c("AMP", "B-ATZ", "BMP", "ECTZ"),
      values = c("darkorchid1", "aquamarine2", "blue1", "orangered1"),
      name = "Bioregion",
      guide = FALSE
    ) +
    scale_colour_gradient(
      name = expression(paste(beta[sim])),
      low = "antiquewhite4",
      high = "antiquewhite"
    ) +
    coord_fixed(ratio = 1, expand = TRUE) +
    scale_x_continuous(labels = function(x) paste0(x, "°E")) +
    scale_y_continuous(labels = function(x) paste0(x, "°S")) +
    scale_alpha_continuous(guide = FALSE) +
    theme_grey() +
    xlab(NULL) +
    ylab(NULL) +
    theme(panel.grid.minor = element_blank()) +
    ggtitle(title)
}

a <- net.plot.Y1(
  Y1.sl.BMP,
  "Benguela Marine Province",
  col.seq = c("black", "black", "white", "black")
) + # alphabetical
  theme(
    legend.direction = "horizontal",
    legend.position = c(x = 0.5, y = 0.8),
    legend.key.height = unit(0.3, "cm")
  )
b <- net.plot.Y1(
  Y1.sl.BATZ,
  "Benguela-Agulhas Transition Zone",
  col.seq = c("black", "white", "black", "black")
) +
  theme(legend.position = "none")
c <- net.plot.Y1(
  Y1.sl.AMP,
  "Agulhas Marine Province",
  col.seq = c("white", "black", "black", "black")
) +
  theme(legend.position = "none")
d <- net.plot.Y1(
  Y1.sl.ECTZ,
  "East Coast Transition Zone",
  col.seq = c("black", "black", "black", "white")
) +
  theme(legend.position = "none")

ggarrange(a, b, c, d, ncol = 2, nrow = 2, labels = "AUTO", common.legend = TRUE)
```

And that is it, folks. You will notice that I have not reproduced Fig. 5 here. I will leave that up to you... or ask me and I will send the code. All of the matrices have (mostly) been calculated above and they can be used together with some **dplyr** and **ggplot2** know-how in the creation of that graph.

Legalise seaweed!

## References

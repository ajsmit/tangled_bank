---
date: "2021-01-01"
title: "4. Data distributions"
subtitle: "Getting familiar with data handling in R"
---

```{r}
#| message: false
#| warning: false
#| echo: false
library(tidyverse)
```

::: {.callout-note appearance="simple"}
## In this Chapter

-   The concept of data distributions
:::

::: {.callout-important appearance="simple"}
## Tasks to complete in this Chapter

-   None
:::

![](/images/wahlberg_distribution.jpeg){fig-align="center" width="600"}

# Introduction

A good grasp of data distributions is a prerequisite of any statistical analysis. It enables us to describe and summarise the underlying patterns, trends, and variations in our data, allowing for more robust predictions and inferences about natural processes, whether they describe the outcomes of experiments or the structure of biodiversity in the nature. By understanding the distribution of our data, biologists and ecologists can select the most appropriate statistical techniques for their analyses, ensuring the validity of their conclusions and ultimately facilitating the development of more robust and defensible insights about our research. As we progress through this Chapter, we will learn about the most common data distributions encountered in ecological research, and how to effectively apply statistical methods to analyse and interpret them.

Let us learn about the different types of data distributions we are likely to encounter in the wild.

# Discrete distributions

A discrete random variable has a finite or countable number of possible values. As the name suggests, it models integer data. Below we provide options to generate and visualise data belonging to several classes of discrete distributions. In [Chapter 6](06-assumptions.qmd) we will learn how to transform these data prior to performing the appropriate statistical analysis.

## Bernoulli and binomial distributions

Bernoulli and Binomial distributions are both discrete probability distributions that describe the *outcomes of binary events*. They are similar but there are also some key differences between the two. In real life examples encountered in ecology and biology we will probably mostly encounter the Binomial distributions. Let us consider each is more detail.

**Bernoulli distribution** The Bernoulli distribution represents a single binary trial or experiment with only two possible outcomes---'success' (usually represented as `1`) and 'failure' (usually represented as `0`). The probability of success is denoted by $p$, while the probability of failure is $1 - p$. A Bernoulli distribution is characterised by only one parameter, $p$, which represents the probability of success for the single trial (@eq-bernoulli).

::: {.column-margin}
**The Bernoulli distribution:**
$$
P(X=k) = \begin{cases} 
  p, & \text{if } k=1 \\
  1-p, & \text{if } k=0
\end{cases}
$$ {#eq-bernoulli}

where $X$ is a random variable, $k$ is the outcome (1 for success and 0 for failure), and $p$ is the probability of success.
:::

**Binomial distribution** The Binomial distribution represents the sum of outcomes in a fixed number of independent Bernoulli trials with the same probability of success, $p$. It is characterised by two parameters---$n$ (the number of trials) and $p$ (the probability of success in each trial). The Binomial distribution describes the probability of obtaining a specific number of successes ($k$) in $n$ trials (@eq-binomial).

::: {.column-margin}
**The Binomial distribution:**
$$P(X=k) = \binom{n}{k} p^k (1-p)^{n-k}$$ {#eq-binomial}

where $X$ is a random variable, $k$ is the number of successes, $n$ is the total number of trials, and $p$ is the probability of success in each trial.
:::

There are several examples of Binomial distributions in ecological and biological contexts. The Binomial distribution is relevant when studying the number of successes in a fixed number of independent trials, each with the same probability of success. A few examples of the Bernoulli distribution in ecological and biological data:

-   **Seed germination** Suppose we plant 100 seeds of a particular plant species and wants to know the probability of a certain number of seeds germinating. If the probability of germination for each seed is constant then we can model the number of germinated seeds by a Binomial distribution.

-   **Disease prevalence** An epidemiologist studies the prevalence of a disease within a population. For a random sample of 500 individuals, and with a fixed probability of an individual having the disease, the number of infected individuals in the sample can be modeled using a Binomial distribution.

-   **Species occupancy** We do an ecological assessment to determine the occupancy of bird species across 50 habitat patches. If the probability of the species occupying a patch is the same across all patches, the number of patches occupied by the species will follow a Binomial distribution.

-   **Allele inheritance** We want to examine the inheritance of a specific trait following Mendelian inheritance patterns. If the probability of inheriting the dominant allele for a given gene is constant, the number of offspring with the dominant trait in a fixed number of offspring follows the Binomial distribution.

Note that in these examples we assume a fixed probability and independence between trials and this is not always be true in real-world situations.

## Negative Binomial distribution

A Negative Binomial random variable, $X$, counts the number of successes in a sequence of independent Bernoulli trials with probability $p$ before $r$ failures occur. This distribution could for example be used to predict the number of heads that result from a series of coin tosses before three tails are observed (@eq-negbinomial).

::: {.column-margin}
**The Negative Binomial distribution:**
$$P(X=k) = \binom{k+r-1}{k} p^r (1-p)^k$$ {#eq-negbinomial}

The equation describes the probability mass function (PMF) of a Negative Binomial distribution, where $X$ is a random variable, $k$ is the number of failures, $r$ is the number of successes, and $p$ is the probability of success in each trial. The binomial coefficient is denoted by $\binom{k+r-1}{k}$, which calculates the number of ways to arrange $k$ failures and $r$ successes such that the last trial is a success.
:::

## Geometric distribution

A geometric random variable, $X$, represents the number of trials that are required to observe a single success. Each trial is independent and has success probability $p$. As an example, the geometric distribution is useful to model the number of times a die must be tossed in order for a six to be observed (@eq-geometric).

::: {.column-margin}
**The Geometric distribution:**
$$P(X=k) = p (1-p)^k$$ {#eq-geometric}

The equation represents the PMF of a Geometric distribution, where $X$ is a random variable, $k$ is the number of failures before the first success, and $p$ is the probability of success in each trial. The Geometric distribution can be thought of as a special case of the Negative Binomial distribution with $r = 1$, which models the number of failures before achieving a single success.
:::

## Poisson distribution

A Poisson random variable, $X$, tallies the number of events occurring in a fixed interval of time or space, given that these events occur with an average rate $\lambda$. Poisson distributions can be used to model events such as meteor showers and or number of people entering a shopping mall (@eq-poisson).

::: {.column-margin}
**The Poisson distribution:**
$$P(X=k) = \frac{e^{-\lambda} \lambda^k}{k!}$$ {#eq-poisson}

The function represents the PMF of a Poisson distribution, where $X$ is a random variable, $k$ is the number of events or occurrences, and $\lambda$ (lambda) is the average rate of occurrences (events per unit of time or space). The constant $e$ is the base of the natural logarithm, and $k!$ is the factorial of $k$. The Poisson distribution is commonly used to model the number of events occurring within a fixed interval of time or space when events occur independently and at a constant average rate.
:::

# Continuous distributions

## Normal distribution {#sec-normal}

::: {.column-margin}
![The idealised Normal distribution showing the proportion of data within 1, 2, and 3SD from the mean.](../../images/Standard_deviation_diagram.svg){#fig-expectednormal}
:::

Another name for this kind of distribution is a Gaussian distribution. A random sample with a Gaussian distribution is normally distributed. These values are *independent and identically distributed* random variables (i.i.d.), and they have an expected mean given by $\mu$ (or $\hat{x}$ in Chapter 3.2.1) and a finite variance given by $\sigma^{2}$ (or $S^{2}$ in Chapter 3.3.1); if the number of samples drawn from a population is sufficiently large, the estimated mean and SD will be indistinguishable from the population (as per the central limit theorem). It is represented by @eq-normal.

::: {.column-margin}
**The Normal distribution:**
$$f(x) = \frac{1}{\sigma\sqrt{2\pi}} e^{ -\frac{1}{2} \left(\frac{x-\mu}{\sigma}\right)^2 }
$$ {#eq-normal}

where $x$ is a continuous random variable, $\mu$ (mu) is the mean, and $\sigma$ (sigma) is the standard deviation. The constant factor $\frac{1}{\sigma\sqrt{2\pi}}$ ensures that the Probability Density Function (PDF) integrates to 1, and the exponential term is responsible for the characteristic bell-shaped curve of the Normal distribution.
:::

::: {.callout-note appearance="simple"}
## Central Limit Theorem

The Central Limit Theorem (CLT) is a fundamental result in probability theory and statistics, which states that the distribution of the sum (or average) of a large number of independent, identically distributed (IID) random variables approaches a Normal distribution regardless of the shape of the original distribution. So, the CLT asserts that the Normal distribution is the limiting distribution for the sum or average of many random variables, as long as certain conditions are met.

The CLT has important implications in statistical analysis, as it provides a basis for making inferences about population parameters using sample statistics. For example, when dealing with large sample sizes, the sampling distribution of the sample mean is approximately normally distributed, even if the underlying population distribution is not normal. This allows us to apply inferential techniques based on the Normal distribution, such as hypothesis testing and constructing confidence intervals, to estimate population parameters using sample data.

Some conditions must be met for the CLT to be true:

-   **The random variables must be independent** The observations should not be influenced by one another.
-   **The random variables must be identically distributed** They must come from the same population with the same mean and variance.
-   **The number of random variables (sample size) must be sufficiently large** Although there is no strict rule for the sample size, a common rule of thumb is that the sample size should be at least 30 for the CLT to be a reasonable approximation.
:::

```{r, echo=FALSE, eval=FALSE}
# library(animation)
# library(e1071)

## The function to animate a histogram
# hist_fig <- function(i){
#   set.seed(666)
#   norm_dat <- data.frame(dat = rnorm(n = i, mean = 10, sd = 1),
#                          sample = "A")
#   hist <- ggplot(data = norm_dat, aes(x = dat)) + 
#     geom_histogram(aes(y = ..density..),
#                  position = 'identity',
#                  colour = "black", fill = "turquoise", alpha = 0.6) +
#     geom_density(colour = "black", fill = "salmon", alpha = 0.6) +
#     annotate("text", x = 6.5, y = 0.35, size = 5, 
#              label = paste0("N = ", i, 
#                             "\nmean = 10", 
#                             "\nSD = 1",
#                             "\nskew = ", round(skewness(norm_dat$dat), 2),
#                             "\nkurt = ", round(kurtosis(norm_dat$dat), 2))) +
#     scale_x_continuous(limits = c(6, 14)) +
#     scale_y_continuous(limits = c(0, 0.4)) +
#     ggtitle("Normal distribution") +
#     labs(x = "value")
#     print(hist)
# }

## Create animation of the histogram
# animate_hist <- function() {
#   lapply(c(rep(10, 5), seq(20, 90, 10), seq(100, 900, 100), seq(900, 1000, 10), rep(1000, 5)), function(i) {
#     hist_fig(i)
#   })
# }

# Note that this spits out in the main directory and is manually moved to the figures folder

# saveGIF(animate_hist())
# system.time(saveGIF(animate_hist(), interval = 0.5, ani.width = 600, movie.name = "hist_norm_n.gif")) ## ~12 seconds
knitr::include_graphics("figures/hist_norm_n.gif")
```

## Uniform distribution

The continuous uniform distribution is sometime called a rectangular distribution. Simply, it states that all measurements of the same magnitude included with this distribution are equally probable. This is basically random numbers.

```{r, echo=FALSE, eval=FALSE}
# Create base distributions
set.seed(666)
unif_dat <- data.frame(dist = c(runif(10, 0, 10), runif(100, 0, 10), runif(1000, 0, 10),
                                runif(10, 0, 50), runif(100, 0, 50), runif(1000, 0, 50),
                                runif(10, 0, 100), runif(100, 0, 100), runif(1000, 0, 100)),
                       unif_group = paste(rep(c(rep("n = 10", 10), rep("n = 100", 100), rep("n = 1000", 1000)), 3),
                                          rep("min = 0", 3330),
                                          c(rep("max = 10", 1110), rep("max = 50", 1110), rep("max = 100", 1110)), 
                                          sep = ", "))

# Create density curves
unif_dens <- data.frame()
for(i in 1:length(levels(unif_dat$unif_group))) {
  x <- density(unif_dat$dist[unif_dat$unif_group == levels(unif_dat$unif_group)[i]])$x
  y <- density(unif_dat$dist[unif_dat$unif_group == levels(unif_dat$unif_group)[i]])$y
  df <- data.frame(x = x, y = y, unif_group = levels(unif_dat$unif_group)[i])
  unif_dens <- rbind(unif_dens, df)
}

# Create all of the buttons
l <- list()
for(i in 1:length(levels(unif_dat$unif_group))) {
  l[[i]] <- list(method = "restyle",
                 args = list("transforms[0].value", unique(unif_dat$unif_group)[i]),
                 label = unique(unif_dat$unif_group)[i])
}

# Run the figure
p <- plot_ly(data = unif_dat, 
             transforms = list(
               list(type = 'filter',
                    target = ~unif_group,
                    operation = '=',
                    value = unique(unif_dat$unif_group)[5]))) %>%
  add_histogram(x = ~dist, name = "Histogram") %>%
  add_boxplot(x = ~dist, yaxis = "y3", name = "Boxplot") %>% 
  add_trace(data = unif_dens, x = ~x, y = ~y, mode = "lines", fill = "tozeroy", 
            yaxis = "y2", name = "Density",
            transforms = list(
              list(type = 'filter',
                   target = ~unif_group,
                   operation = '=',
                   value = unique(unif_dat$unif_group)[5]))) %>%
  layout(title = "Uniform distribution",
         xaxis = list(title = "value"), 
         yaxis = list(title = "count"),
         yaxis2 = list(overlaying = "y", zeroline = FALSE,
                       showline = FALSE, showticklabels = FALSE, showgrid = FALSE),
         yaxis3 = list(overlaying = "y"),
         updatemenus = list(list(y = 1.05, x = 0.2, active = 4, buttons = l)))
p
```

## Student T distribution

This is a continuous probability distribution that arises when estimating the mean of a normally distributed population in situations where the sample size is small and population standard deviation is unknown. It is used in the statistical significance testing between the means of different sets of samples, and not much so in the modelling of natural phenomena.

```{r, echo=FALSE, eval=FALSE}
# Create base distributions
set.seed(666)
t_dat <- data.frame(dist =    c(rt(10, 5, 0), rt(100, 5, 0), rt(1000, 5, 0),
                                rt(10, 20, 0), rt(100, 20, 0), rt(1000, 20, 0),
                                rt(10, 100, 0), rt(100, 100, 0), rt(1000, 100, 0),
                                rt(10, 5, 3), rt(100, 5, 3), rt(1000, 5, 3),
                                rt(10, 20, 3), rt(100, 20, 3), rt(1000, 20, 3),
                                rt(10, 100, 3), rt(100, 100, 3), rt(1000, 100, 3),
                                rt(10, 5, 6), rt(100, 5, 6), rt(1000, 5, 6),
                                rt(10, 20, 6), rt(100, 20, 6), rt(1000, 20, 6),
                                rt(10, 100, 6), rt(100, 100, 6), rt(1000, 100, 6)),
                       t_group = paste(rep(c(rep("n = 10", 10), rep("n = 100", 100), rep("n = 1000", 1000)), 9),
                                          rep(c(rep("df = 5", 1110), rep("df = 20", 1110), rep("df = 100", 1110)), 3),
                                          c(rep("ncp = 0", 3330), rep("ncp = 3", 3330), rep("ncp = 6", 3330)), 
                                          sep = ", "))

# Create density curves
t_dens <- data.frame()
for(i in 1:length(levels(t_dat$t_group))) {
  x <- density(t_dat$dist[t_dat$t_group == levels(t_dat$t_group)[i]])$x
  y <- density(t_dat$dist[t_dat$t_group == levels(t_dat$t_group)[i]])$y
  df <- data.frame(x = x, y = y, t_group = levels(t_dat$t_group)[i])
  t_dens <- rbind(t_dens, df)
}

# Create all of the buttons
l <- list()
for(i in 1:length(levels(t_dat$t_group))) {
  l[[i]] <- list(method = "restyle",
                 args = list("transforms[0].value", unique(t_dat$t_group)[i]),
                 label = unique(t_dat$t_group)[i])
}

# Run the figure
p <- plot_ly(data = t_dat, 
             transforms = list(
               list(type = 'filter',
                    target = ~t_group,
                    operation = '=',
                    value = unique(t_dat$t_group)[14]))) %>%
  add_histogram(x = ~dist, name = "Histogram") %>%
  add_boxplot(x = ~dist, yaxis = "y3", name = "Boxplot") %>% 
  add_trace(data = t_dens, x = ~x, y = ~y, mode = "lines", fill = "tozeroy", 
            yaxis = "y2", name = "Density",
            transforms = list(
              list(type = 'filter',
                   target = ~t_group,
                   operation = '=',
                   value = unique(t_dat$t_group)[14]))) %>%
  layout(title = "Student T distribution",
         xaxis = list(title = "value"), 
         yaxis = list(title = "count"),
         yaxis2 = list(overlaying = "y", zeroline = FALSE,
                       showline = FALSE, showticklabels = FALSE, showgrid = FALSE),
         yaxis3 = list(overlaying = "y"),
         updatemenus = list(list(y = 1.05, x = 0.2, active = 13, buttons = l)))
p
```

## Chi-squared distribution

Mostly used in hypothesis testing, but not to encapsulate the distribution of data drawn to represent natural phenomena.

```{r, echo=FALSE, eval=FALSE}
# Create base distributions
set.seed(666)
chisq_dat <- data.frame(dist = c(rchisq(10, 5, 0), rchisq(100, 5, 0), rchisq(1000, 5, 0),
                                rchisq(10, 20, 0), rchisq(100, 20, 0), rchisq(1000, 20, 0),
                                rchisq(10, 100, 0), rchisq(100, 100, 0), rchisq(1000, 100, 0),
                                rchisq(10, 5, 2), rchisq(100, 5, 2), rchisq(1000, 5, 2),
                                rchisq(10, 20, 2), rchisq(100, 20, 2), rchisq(1000, 20, 2),
                                rchisq(10, 100, 2), rchisq(100, 100, 2), rchisq(1000, 100, 2),
                                rchisq(10, 5, 4), rchisq(100, 5, 4), rchisq(1000, 5, 4),
                                rchisq(10, 20, 4), rchisq(100, 20, 4), rchisq(1000, 20, 4),
                                rchisq(10, 100, 4), rchisq(100, 100, 4), rchisq(1000, 100, 4)),
                    chisq_group = paste(rep(c(rep("n = 10", 10), rep("n = 100", 100), rep("n = 1000", 1000)), 9),
                                    rep(c(rep("df = 5", 1110), rep("df = 20", 1110), rep("df = 100", 1110)), 3),
                                    c(rep("ncp = 0", 3330), rep("ncp = 2", 3330), rep("ncp = 4", 3330)), 
                                          sep = ", "))

# Create density curves
chisq_dens <- data.frame()
for(i in 1:length(levels(chisq_dat$chisq_group))) {
  x <- density(chisq_dat$dist[chisq_dat$chisq_group == levels(chisq_dat$chisq_group)[i]])$x
  y <- density(chisq_dat$dist[chisq_dat$chisq_group == levels(chisq_dat$chisq_group)[i]])$y
  df <- data.frame(x = x, y = y, chisq_group = levels(chisq_dat$chisq_group)[i])
  chisq_dens <- rbind(chisq_dens, df)
}

# Create all of the buttons
l <- list()
for(i in 1:length(levels(chisq_dat$chisq_group))) {
  l[[i]] <- list(method = "restyle",
                 args = list("transforms[0].value", unique(chisq_dat$chisq_group)[i]),
                 label = unique(chisq_dat$chisq_group)[i])
}

# Run the figure
p <- plot_ly(data = chisq_dat, 
             transforms = list(
               list(type = 'filter',
                    target = ~chisq_group,
                    operation = '=',
                    value = unique(chisq_dat$chisq_group)[14]))) %>%
  add_histogram(x = ~dist, name = "Histogram") %>%
  add_boxplot(x = ~dist, yaxis = "y3", name = "Boxplot") %>% 
  add_trace(data = chisq_dens, x = ~x, y = ~y, mode = "lines", fill = "tozeroy", 
            yaxis = "y2", name = "Density",
            transforms = list(
              list(type = 'filter',
                   target = ~chisq_group,
                   operation = '=',
                   value = unique(chisq_dat$chisq_group)[14]))) %>%
  layout(title = "Chi-squared distribution",
         xaxis = list(title = "value"), 
         yaxis = list(title = "count"),
         yaxis2 = list(overlaying = "y", zeroline = FALSE,
                       showline = FALSE, showticklabels = FALSE, showgrid = FALSE),
         yaxis3 = list(overlaying = "y"),
         updatemenus = list(list(y = 1.05, x = 0.2, active = 13, buttons = l)))
p
```

## Exponential distribution

This is a probability distribution that describes the time between events in a Poisson point process, i.e., a process in which events occur continuously and independently at a constant average rate.

```{r, echo=FALSE, eval=FALSE}
# Create base distributions
set.seed(666)
exp_dat <- data.frame(dist = c(rexp(10, 1), rexp(100, 1), rexp(1000, 1),
                                rexp(10, 2), rexp(100, 2), rexp(1000, 2),
                                rexp(10, 3), rexp(100, 3), rexp(1000, 3)),
                       exp_group = paste(rep(c(rep("n = 10", 10), rep("n = 100", 100), rep("n = 1000", 1000)), 3),
                                          c(rep("rate = 1", 1110), rep("rate = 2", 1110), rep("rate = 3", 1110)), 
                                          sep = ", "))

# Create density curves
exp_dens <- data.frame()
for(i in 1:length(levels(exp_dat$exp_group))) {
  x <- density(exp_dat$dist[exp_dat$exp_group == levels(exp_dat$exp_group)[i]])$x
  y <- density(exp_dat$dist[exp_dat$exp_group == levels(exp_dat$exp_group)[i]])$y
  df <- data.frame(x = x, y = y, exp_group = levels(exp_dat$exp_group)[i])
  exp_dens <- rbind(exp_dens, df)
}

# Create all of the buttons
l <- list()
for(i in 1:length(levels(exp_dat$exp_group))) {
  l[[i]] <- list(method = "restyle",
                 args = list("transforms[0].value", unique(exp_dat$exp_group)[i]),
                 label = unique(exp_dat$exp_group)[i])
}

# Run the figure
p <- plot_ly(data = exp_dat, 
             transforms = list(
               list(type = 'filter',
                    target = ~exp_group,
                    operation = '=',
                    value = unique(exp_dat$exp_group)[5]))) %>%
  add_histogram(x = ~dist, name = "Histogram") %>%
  add_boxplot(x = ~dist, yaxis = "y3", name = "Boxplot") %>% 
  add_trace(data = exp_dens, x = ~x, y = ~y, mode = "lines", fill = "tozeroy", 
            yaxis = "y2", name = "Density",
            transforms = list(
              list(type = 'filter',
                   target = ~exp_group,
                   operation = '=',
                   value = unique(exp_dat$exp_group)[5]))) %>%
  layout(title = "Exponential distribution",
         xaxis = list(title = "observed occurrences"), 
         yaxis = list(title = "count"),
         yaxis2 = list(overlaying = "y", zeroline = FALSE,
                       showline = FALSE, showticklabels = FALSE, showgrid = FALSE),
         yaxis3 = list(overlaying = "y"),
         updatemenus = list(list(y = 1.05, x = 0.2, active = 4, buttons = l)))
p
```

## F distribution

```{r, echo=FALSE, eval=FALSE}
# Create base distributions
set.seed(666)
f_dat <- data.frame(dist =     c(rf(10, 5, 5), rf(100, 5, 5), rf(1000, 5, 5),
                                 rf(10, 20, 5), rf(100, 20, 5), rf(1000, 20, 5),
                                 rf(10, 100, 5), rf(100, 100, 5), rf(1000, 100, 5),
                                 rf(10, 5, 20), rf(100, 5, 20), rf(1000, 5, 20),
                                 rf(10, 20, 20), rf(100, 20, 20), rf(1000, 20, 20),
                                 rf(10, 100, 20), rf(100, 100, 20), rf(1000, 100, 20),
                                 rf(10, 5, 100), rf(100, 5, 100), rf(1000, 5, 100),
                                 rf(10, 20, 100), rf(100, 20, 100), rf(1000, 20, 100),
                                 rf(10, 100, 100), rf(100, 100, 100), rf(1000, 100, 100)),
                        f_group = paste(rep(c(rep("n = 10", 10), rep("n = 100", 100), rep("n = 1000", 1000)), 9),
                                            rep(c(rep("df1 = 5", 1110), rep("df1 = 20", 1110), rep("df1 = 100", 1110)), 3),
                                            c(rep("df2 = 5", 3330), rep("df2 = 20", 3330), rep("df2 = 100", 3330)), 
                                          sep = ", "))

# Create density curves
f_dens <- data.frame()
for(i in 1:length(levels(f_dat$f_group))) {
  x <- density(f_dat$dist[f_dat$f_group == levels(f_dat$f_group)[i]])$x
  y <- density(f_dat$dist[f_dat$f_group == levels(f_dat$f_group)[i]])$y
  df <- data.frame(x = x, y = y, f_group = levels(f_dat$f_group)[i])
  f_dens <- rbind(f_dens, df)
}

# Create all of the buttons
l <- list()
for(i in 1:length(levels(f_dat$f_group))) {
  l[[i]] <- list(method = "restyle",
                 args = list("transforms[0].value", unique(f_dat$f_group)[i]),
                 label = unique(f_dat$f_group)[i])
}

# Run the figure
p <- plot_ly(data = f_dat, 
             transforms = list(
               list(type = 'filter',
                    target = ~f_group,
                    operation = '=',
                    value = unique(f_dat$f_group)[14]))) %>%
  add_histogram(x = ~dist, name = "Histogram") %>%
  add_boxplot(x = ~dist, yaxis = "y3", name = "Boxplot") %>% 
  add_trace(data = f_dens, x = ~x, y = ~y, mode = "lines", fill = "tozeroy", 
            yaxis = "y2", name = "Density",
            transforms = list(
              list(type = 'filter',
                   target = ~f_group,
                   operation = '=',
                   value = unique(f_dat$f_group)[14]))) %>%
  layout(title = "F distribution",
         xaxis = list(title = "value"), 
         yaxis = list(title = "count"),
         yaxis2 = list(overlaying = "y", zeroline = FALSE,
                       showline = FALSE, showticklabels = FALSE, showgrid = FALSE),
         yaxis3 = list(overlaying = "y"),
         updatemenus = list(list(y = 1.05, x = 0.2, active = 13, buttons = l)))
p
```

## Gamma distribution

```{r, echo=FALSE, eval=FALSE}
# Create base distributions
set.seed(666)
gamma_dat <- data.frame(dist = c(rgamma(10, 1), rgamma(100, 1), rgamma(1000, 1),
                               rgamma(10, 2), rgamma(100, 2), rgamma(1000, 2),
                               rgamma(10, 3), rgamma(100, 3), rgamma(1000, 3)),
                      gamma_group = paste(rep(c(rep("n = 10", 10), rep("n = 100", 100), rep("n = 1000", 1000)), 3),
                                        c(rep("shape = 1", 1110), rep("shape = 2", 1110), rep("shape = 3", 1110)), 
                                          sep = ", "))

# Create density curves
gamma_dens <- data.frame()
for(i in 1:length(levels(gamma_dat$gamma_group))) {
  x <- density(gamma_dat$dist[gamma_dat$gamma_group == levels(gamma_dat$gamma_group)[i]])$x
  y <- density(gamma_dat$dist[gamma_dat$gamma_group == levels(gamma_dat$gamma_group)[i]])$y
  df <- data.frame(x = x, y = y, gamma_group = levels(gamma_dat$gamma_group)[i])
  gamma_dens <- rbind(gamma_dens, df)
}

# Create all of the buttons
l <- list()
for(i in 1:length(levels(gamma_dat$gamma_group))) {
  l[[i]] <- list(method = "restyle",
                 args = list("transforms[0].value", unique(gamma_dat$gamma_group)[i]),
                 label = unique(gamma_dat$gamma_group)[i])
}

# Run the figure
p <- plot_ly(data = gamma_dat, 
             transforms = list(
               list(type = 'filter',
                    target = ~gamma_group,
                    operation = '=',
                    value = unique(gamma_dat$gamma_group)[5]))) %>%
  add_histogram(x = ~dist, name = "Histogram") %>%
  add_boxplot(x = ~dist, yaxis = "y3", name = "Boxplot") %>% 
  add_trace(data = gamma_dens, x = ~x, y = ~y, mode = "lines", fill = "tozeroy", 
            yaxis = "y2", name = "Density",
            transforms = list(
              list(type = 'filter',
                   target = ~gamma_group,
                   operation = '=',
                   value = unique(gamma_dat$gamma_group)[5]))) %>%
  layout(title = "Gamma distribution",
         xaxis = list(title = "value"), 
         yaxis = list(title = "count"),
         yaxis2 = list(overlaying = "y", zeroline = FALSE,
                       showline = FALSE, showticklabels = FALSE, showgrid = FALSE),
         yaxis3 = list(overlaying = "y"),
         updatemenus = list(list(y = 1.05, x = 0.2, active = 4, buttons = l)))
p
```

## Beta distribution

```{r, echo=FALSE, eval=FALSE}
# Create base distributions
set.seed(666)
beta_dat <- data.frame(dist = c(rbeta(10, 1, 1), rbeta(100, 1, 1), rbeta(1000, 1, 1),
                                rbeta(10, 2, 1), rbeta(100, 2, 1), rbeta(1000, 2, 1),
                                rbeta(10, 3, 1), rbeta(100, 3, 1), rbeta(1000, 3, 1),
                                rbeta(10, 1, 2), rbeta(100, 1, 2), rbeta(1000, 1, 2),
                                rbeta(10, 2, 2), rbeta(100, 2, 2), rbeta(1000, 2, 2),
                                rbeta(10, 3, 2), rbeta(100, 3, 2), rbeta(1000, 3, 2),
                                rbeta(10, 1, 3), rbeta(100, 1, 3), rbeta(1000, 1, 3),
                                rbeta(10, 2, 3), rbeta(100, 2, 3), rbeta(1000, 2, 3),
                                rbeta(10, 3, 3), rbeta(100, 3, 3), rbeta(1000, 3, 3)),
                       beta_group = paste(rep(c(rep("n = 10", 10), rep("n = 100", 100), rep("n = 1000", 1000)), 9),
                                          rep(c(rep("shape1 = 1", 1110), rep("shape1 = 2", 1110), rep("shape3 = 3", 1110)), 3),
                                          c(rep("shape2 = 1", 3330), rep("shape2 = 2", 3330), rep("shape3 = 3", 3330)), 
                                          sep = ", "))
# Create density curves
beta_dens <- data.frame()
for(i in 1:length(levels(beta_dat$beta_group))) {
  x <- density(beta_dat$dist[beta_dat$beta_group == levels(beta_dat$beta_group)[i]])$x
  y <- density(beta_dat$dist[beta_dat$beta_group == levels(beta_dat$beta_group)[i]])$y
  df <- data.frame(x = x, y = y, beta_group = levels(beta_dat$beta_group)[i])
  beta_dens <- rbind(beta_dens, df)
}

# Create all of the buttons
l <- list()
for(i in 1:length(levels(beta_dat$beta_group))) {
  l[[i]] <- list(method = "restyle",
                 args = list("transforms[0].value", unique(beta_dat$beta_group)[i]),
                 label = unique(beta_dat$beta_group)[i])
}

# Run the figure
p <- plot_ly(data = beta_dat, 
             transforms = list(
               list(type = 'filter',
                    target = ~beta_group,
                    operation = '=',
                    value = unique(beta_dat$beta_group)[8]))) %>%
  add_histogram(x = ~dist, name = "Histogram") %>%
  add_boxplot(x = ~dist, yaxis = "y3", name = "Boxplot") %>% 
  add_trace(data = beta_dens, x = ~x, y = ~y, mode = "lines", fill = "tozeroy", 
            yaxis = "y2", name = "Density",
            transforms = list(
              list(type = 'filter',
                   target = ~beta_group,
                   operation = '=',
                   value = unique(beta_dat$beta_group)[8]))) %>%
  layout(title = "Beta distribution",
         xaxis = list(title = "value"), 
         yaxis = list(title = "count"),
         yaxis2 = list(overlaying = "y", zeroline = FALSE,
                       showline = FALSE, showticklabels = FALSE, showgrid = FALSE),
         yaxis3 = list(overlaying = "y"),
         updatemenus = list(list(y = 1.05, x = 0.2, active = 7, buttons = l)))
p
```

# Finding one's data distribution

Data belonging to a sample will never exactly follow a specific distribution, even when the test for normality says it does---there will always be a small probability that they are non-normal and is in fact better described by some other distribution. In other words, data are only *compatible* with a certain distribution, and one can never answer the question "Does my data follow the distribution xy exactly?" as simply as providing a yes/no answer. So what now? How does one find one's data distribution? We can use the *Cullen and Frey graph* function that lives in the **fitdistrplus** package. This graph tells us whether the skewness and kurtosis of our data are consistent with that of a particular distribution. We will demonstrate by generating various data distributions and testing them using the Cullen and Frey graph.

```{r dist-plot1, message=FALSE}
#| column: screen-inset-shaded
#| layout-nrow: 1

library(fitdistrplus)
library(logspline)

# Generate log-normal data
y <- c(37.50,46.79,48.30,46.04,43.40,39.25,38.49,49.51,40.38,36.98,40.00,
38.49,37.74,47.92,44.53,44.91,44.91,40.00,41.51,47.92,36.98,43.40,
42.26,41.89,38.87,43.02,39.25,40.38,42.64,36.98,44.15,44.91,43.40,
49.81,38.87,40.00,52.45,53.13,47.92,52.45,44.91,29.54,27.13,35.60,
45.34,43.37,54.15,42.77,42.88,44.26,27.14,39.31,24.80,16.62,30.30,
36.39,28.60,28.53,35.84,31.10,34.55,52.65,48.81,43.42,52.49,38.00,
38.65,34.54,37.70,38.11,43.05,29.95,32.48,24.63,35.33,41.34)

plot(x = c(1:length(y)), y = y)
hist(y)
descdist(y, discrete = FALSE, boot = 100)
```

```{r dist-plot2}
#| column: screen-inset-shaded
#| layout-nrow: 1

# normally distributed data
y <- rnorm(100, 13, 2)

plot(x = c(1:100), y = y)
hist(y)
descdist(y, discrete = FALSE)
```

```{r dist-plot3}
#| column: screen-inset-shaded
#| layout-nrow: 1

# uniformly distributed data
y <- runif(100)

plot(x = c(1:100), y = y)
hist(y)
descdist(y, discrete = FALSE)
```

```{r dist-plot4, width = 6, height = 10}
#| column: screen-inset-shaded
#| layout-nrow: 1

# uniformly distributed data
y <- rexp(100, 0.7)

plot(x = c(1:100), y = y)
hist(y)
descdist(y, discrete = FALSE)
```

There is also a whole bunch of other approaches to use to try and identify the data distribution. Let us start with the gold standard first: normal data. We will demonstrate some visualisation approaches. The one that you already know is a basic histogram; it tells us something about the distribution's skewness, the tails, the mode(s) of the data, outliers, etc. Histograms can be compared to shapes associated with idealistic (simulated) distributions, as we will do here.

```{r dist-plot5}
#| column: margin

y <-rnorm(n = 200, m = 13, sd = 2)
par(mfrow = c(2, 2))
# using some basic base graphics as ggplot2 is overkill;
# we can get a histogram using hist() statement
hist(y, main = "Histogram of observed data")
plot(density(y), main = "Density estimate of data")
plot(ecdf(y), main = "Empirical cumulative distribution function")
# standardise the data
z.norm <- (y - mean(y)) / sd(y) 
# make a qqplot
qqnorm(z.norm)
# add a 45-degree reference line
abline(0, 1)
```

Above we have also added a diagonal line to the qqplot. If the sampled data come from the population with the chosen distribution, the points should fall approximately along this reference line. The greater the departure from this reference line, the greater the evidence for the conclusion that the data set have come from a population with a different distribution.

```{r}
# curve(dnorm(100, m = 10, sd = 2), from = 0, to = 20, main = "Normal distribution")
# curve(dgamma(100, scale = 1.5, shape = 2), from = 0, to = 15, main = "Gamma distribution")
# curve(dweibull(100, scale = 2.5, shape = 1.5), from = 0, to = 15, main = "Weibull distribution")
```

<!-- ## Exercises -->

<!-- ### Exercise 1 -->

<!-- Choose two different datasets and plot them as histograms with density curves overlayed. Label them with the distribution they appear to be and stitch them together with `ggarrange()`. -->
